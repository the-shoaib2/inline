/**
 * Vulnerability Scanner
 * Scans dependencies for security vulnerabilities
 */
export class VulnerabilityScanner {
    
    private knownVulnerabilities: Record<string, { severity: string; description: string }> = {
        'lodash@<4.17.21': {
            severity: 'high',
            description: 'Prototype pollution vulnerability'
        },
        'axios@<0.21.1': {
            severity: 'moderate',
            description: 'Server-Side Request Forgery'
        },
        'minimist@<1.2.6': {
            severity: 'critical',
            description: 'Prototype pollution'
        }
    };

    async scanDependencies(packageJsonPath: string): Promise<Array<{
        package: string;
        version: string;
        vulnerability: string;
        severity: string;
        fix: string;
    }>> {
        const vulnerabilities: Array<{
            package: string;
            version: string;
            vulnerability: string;
            severity: string;
            fix: string;
        }> = [];

        try {
            const fs = require('fs');
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
            const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

            for (const [pkg, version] of Object.entries(dependencies)) {
                const vulnKey = `${pkg}@${version}`;
                const vuln = this.knownVulnerabilities[vulnKey];
                
                if (vuln) {
                    vulnerabilities.push({
                        package: pkg,
                        version: version as string,
                        vulnerability: vuln.description,
                        severity: vuln.severity,
                        fix: 'Update to latest version'
                    });
                }
            }
        } catch (error) {
            console.error('Error scanning dependencies:', error);
        }

        return vulnerabilities;
    }

    async scanCode(code: string): Promise<Array<{
        line: number;
        issue: string;
        severity: string;
    }>> {
        const issues: Array<{ line: number; issue: string; severity: string }> = [];
        const lines = code.split('\n');

        lines.forEach((line, index) => {
            // Check for eval usage
            if (line.includes('eval(')) {
                issues.push({
                    line: index + 1,
                    issue: 'Use of eval() is dangerous and should be avoided',
                    severity: 'high'
                });
            }

            // Check for SQL injection risks
            if (/\$\{.*\}/.test(line) && /SELECT|INSERT|UPDATE|DELETE/.test(line)) {
                issues.push({
                    line: index + 1,
                    issue: 'Potential SQL injection vulnerability',
                    severity: 'critical'
                });
            }

            // Check for hardcoded credentials
            if (/password\s*=\s*['"][^'"]+['"]|api_key\s*=\s*['"][^'"]+['"]/i.test(line)) {
                issues.push({
                    line: index + 1,
                    issue: 'Hardcoded credentials detected',
                    severity: 'critical'
                });
            }

            // Check for insecure random
            if (line.includes('Math.random()') && /token|password|key|secret/i.test(line)) {
                issues.push({
                    line: index + 1,
                    issue: 'Math.random() is not cryptographically secure',
                    severity: 'moderate'
                });
            }
        });

        return issues;
    }

    generateReport(vulnerabilities: any[], codeIssues: any[]): string {
        let report = '# Security Scan Report\n\n';
        
        if (vulnerabilities.length > 0) {
            report += '## Dependency Vulnerabilities\n\n';
            vulnerabilities.forEach(v => {
                report += `- **${v.package}@${v.version}** (${v.severity})\n`;
                report += `  - ${v.vulnerability}\n`;
                report += `  - Fix: ${v.fix}\n\n`;
            });
        }

        if (codeIssues.length > 0) {
            report += '## Code Security Issues\n\n';
            codeIssues.forEach(issue => {
                report += `- Line ${issue.line} (${issue.severity}): ${issue.issue}\n`;
            });
        }

        if (vulnerabilities.length === 0 && codeIssues.length === 0) {
            report += 'No security issues found! âœ…\n';
        }

        return report;
    }
}
